{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///router.min.js","webpack:///webpack/bootstrap b2141e00868f4f4f7858","webpack:///./router.js","webpack:///external \"riot\"","webpack:///./~/riot-route/index.js","webpack:///./~/riot-observable/dist/observable.js","webpack:///./src/router.js","webpack:///./~/extend/index.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","apply","undefined","riot","route","Router","router","create","window","_interopDefault","ex","DEFAULT_PARSER","path","split","DEFAULT_SECOND_PARSER","filter","f","replace","re","RegExp","args","match","slice","debounce","fn","delay","t","clearTimeout","setTimeout","start","autoExec","debouncedEmit","emit","win","ADD_EVENT_LISTENER","POPSTATE","HASHCHANGE","doc","clickEvent","click","$","observable","central","on","s","bind","e","normalize","isString","str","getPathFromRoot","href","loc","RE_ORIGIN","getPathFromBase","base","_","force","isRoot","emitStackLevel","MAX_EMIT_STACK_LEVEL","emitStack","push","current","TRIGGER","first","shift","which","metaKey","ctrlKey","shiftKey","defaultPrevented","el","target","nodeName","parentNode","HAS_ATTRIBUTE","indexOf","go","title","Object","keys","find","key","includes","preventDefault","shouldReplace","hist","replaceState","pushState","routeFound","parser","secondParser","EVENT_LISTENER","REMOVE_EVENT_LISTENER","document","history","location","prot","prototype","ontouchstart","started","second","third","r","off","concat","some","action","mainRouter","newSubRouter","stop","arg","exec","fn2","query","q","k","v","readyState","onreadystatechange","callbacks","Array","defineProperties","value","event","enumerable","writable","configurable","cb","arr","i","splice","one","arguments","trigger","fns","arglen","length","extend","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","TypeError","constructor","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","registerTag","tag","opts","calculateLevel","level","parent","__router_level","__router_tag","normalizeTag","api","options","result","unmountTag","unmount","mountTag","_normalizeTag","_normalizeTag2","_slicedToArray","canUpdate","console","debug","update","replaceChild","createElement","children","mount","error","instanceTag","instanceApi","_this6","reRenderOnPropChange","opt","updatable","config","isMounted","updateRoute","response","size","matcher","get","params","detectRoute","configure","raw","uri","forEach","sliceIterator","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","isArray","_get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","getPrototypeOf","getter","_createClass","props","descriptor","defineProperty","protoProps","staticProps","interceptors","processRoute","handler","InitialRoute","Context","process","routes","interceptor","join","context","Request","rootContext","processRequest","processInterceptors","processResponse","isRedirect","processRedirect","request","redirectTo","addRedirect","navigateTo","preInterceptors","postInterceptors","processor","Response","redirectStack","Error","Handler","matches","routeMatch","routeMiss","add","ChildRequest","Route","_Handler","_this","name","pathParameterNames","getPath","pattern","ignored","group","regex","redirectRoutes","RedirectRoute","defaultRoutes","DefaultRoute","notFoundRoutes","NotFoundRoute","otherRoutes","_routes","hasOwnProperty","decodeURIComponent","parseInt","found","processRoutes","createRequest","_Route","substring","parentUri","_Handler2","_this3","_Handler3","_this4","from","to","_Handler4","_this5","trim","index","hasOwn","toStr","toString","gOPD","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","setProperty","newValue","getProperty","src","copy","copyIsArray","clone","deep"],"mappings":"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","file":"router.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"riot\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"riot\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Router\"] = factory(require(\"riot\"));\n\telse\n\t\troot[\"Router\"] = factory(root[\"riot\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"riot\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"riot\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Router\"] = factory(require(\"riot\"));\n\telse\n\t\troot[\"Router\"] = factory(root[\"riot\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__(1), __webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports !== \"undefined\") {\n\t        factory(module, require('riot'), require('riot-route'), require('./src/router.js'));\n\t    } else {\n\t        var mod = {\n\t            exports: {}\n\t        };\n\t        factory(mod, global.riot, global.riotRoute, global.router);\n\t        global.router = mod.exports;\n\t    }\n\t})(this, function (module, riot, route, Router) {\n\t    'use strict';\n\t\n\t    var router = Router.create({ route: route });\n\t    if (window) {\n\t        window.router = router;\n\t    }\n\t    module.exports = Router;\n\t});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar observable = _interopDefault(__webpack_require__(3));\n\t\n\t/**\n\t * Simple client-side router\n\t * @module riot-route\n\t */\n\t\n\tvar RE_ORIGIN = /^.+?\\/\\/+[^/]+/,\n\t  EVENT_LISTENER = 'EventListener',\n\t  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n\t  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n\t  HAS_ATTRIBUTE = 'hasAttribute',\n\t  POPSTATE = 'popstate',\n\t  HASHCHANGE = 'hashchange',\n\t  TRIGGER = 'trigger',\n\t  MAX_EMIT_STACK_LEVEL = 3,\n\t  win = typeof window != 'undefined' && window,\n\t  doc = typeof document != 'undefined' && document,\n\t  hist = win && history,\n\t  loc = win && (hist.location || win.location), // see html5-history-api\n\t  prot = Router.prototype, // to minify more\n\t  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n\t  central = observable();\n\t\n\tvar\n\t  started = false,\n\t  routeFound = false,\n\t  debouncedEmit,\n\t  current,\n\t  parser,\n\t  secondParser,\n\t  emitStack = [],\n\t  emitStackLevel = 0;\n\t\n\t/**\n\t * Default parser. You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_PARSER(path) {\n\t  return path.split(/[/?#]/)\n\t}\n\t\n\t/**\n\t * Default parser (second). You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @param {string} filter - filter string (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_SECOND_PARSER(path, filter) {\n\t  var f = filter\n\t    .replace(/\\?/g, '\\\\?')\n\t    .replace(/\\*/g, '([^/?#]+?)')\n\t    .replace(/\\.\\./, '.*');\n\t  var re = new RegExp((\"^\" + f + \"$\"));\n\t  var args = path.match(re);\n\t\n\t  if (args) { return args.slice(1) }\n\t}\n\t\n\t/**\n\t * Simple/cheap debounce implementation\n\t * @param   {function} fn - callback\n\t * @param   {number} delay - delay in seconds\n\t * @returns {function} debounced function\n\t */\n\tfunction debounce(fn, delay) {\n\t  var t;\n\t  return function () {\n\t    clearTimeout(t);\n\t    t = setTimeout(fn, delay);\n\t  }\n\t}\n\t\n\t/**\n\t * Set the window listeners to trigger the routes\n\t * @param {boolean} autoExec - see route.start\n\t */\n\tfunction start(autoExec) {\n\t  debouncedEmit = debounce(emit, 1);\n\t  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit);\n\t  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n\t  doc[ADD_EVENT_LISTENER](clickEvent, click);\n\t\n\t  if (autoExec) { emit(true); }\n\t}\n\t\n\t/**\n\t * Router class\n\t */\n\tfunction Router() {\n\t  this.$ = [];\n\t  observable(this); // make it observable\n\t  central.on('stop', this.s.bind(this));\n\t  central.on('emit', this.e.bind(this));\n\t}\n\t\n\tfunction normalize(path) {\n\t  return path.replace(/^\\/|\\/$/, '')\n\t}\n\t\n\tfunction isString(str) {\n\t  return typeof str == 'string'\n\t}\n\t\n\t/**\n\t * Get the part after domain name\n\t * @param {string} href - fullpath\n\t * @returns {string} path from root\n\t */\n\tfunction getPathFromRoot(href) {\n\t  return (href || loc.href).replace(RE_ORIGIN, '')\n\t}\n\t\n\t/**\n\t * Get the part after base\n\t * @param {string} href - fullpath\n\t * @returns {string} path from base\n\t */\n\tfunction getPathFromBase(href) {\n\t  var base = route._.base;\n\t  return base[0] === '#'\n\t    ? (href || loc.href || '').split(base)[1] || ''\n\t    : (loc ? getPathFromRoot(href) : href || '').replace(base, '')\n\t}\n\t\n\tfunction emit(force) {\n\t  // the stack is needed for redirections\n\t  var isRoot = emitStackLevel === 0;\n\t  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) { return }\n\t\n\t  emitStackLevel++;\n\t  emitStack.push(function() {\n\t    var path = getPathFromBase();\n\t    if (force || path !== current) {\n\t      central[TRIGGER]('emit', path);\n\t      current = path;\n\t    }\n\t  });\n\t\n\t  if (isRoot) {\n\t    var first;\n\t    while (first = emitStack.shift()) { first(); } // stack increses within this call\n\t    emitStackLevel = 0;\n\t  }\n\t}\n\t\n\tfunction click(e) {\n\t  if (\n\t    e.which !== 1 // not left click\n\t    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n\t    || e.defaultPrevented // or default prevented\n\t  ) { return }\n\t\n\t  var el = e.target;\n\t  while (el && el.nodeName !== 'A') { el = el.parentNode; }\n\t\n\t  if (\n\t    !el || el.nodeName !== 'A' // not A tag\n\t    || el[HAS_ATTRIBUTE]('download') // has download attr\n\t    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n\t    || el.target && el.target !== '_self' // another window or frame\n\t    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) === -1 // cross origin\n\t  ) { return }\n\t\n\t  var base = route._.base;\n\t\n\t  if (el.href !== loc.href\n\t    && (\n\t      el.href.split('#')[0] === loc.href.split('#')[0] // internal jump\n\t      || base[0] !== '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n\t      || base[0] === '#' && el.href.split(base)[0] !== loc.href.split(base)[0] // outside of #base\n\t      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n\t    )) { return }\n\t\n\t  if (!Object.keys(el).find(function (key) { return key.includes('react') })) {\n\t    e.preventDefault();\n\t  }\n\t}\n\t\n\t/**\n\t * Go to the path\n\t * @param {string} path - destination path\n\t * @param {string} title - page title\n\t * @param {boolean} shouldReplace - use replaceState or pushState\n\t * @returns {boolean} - route not found flag\n\t */\n\tfunction go(path, title, shouldReplace) {\n\t  // Server-side usage: directly execute handlers for the path\n\t  if (!hist) { return central[TRIGGER]('emit', getPathFromBase(path)) }\n\t\n\t  path = route._.base + normalize(path);\n\t  title = title || doc.title;\n\t  // browsers ignores the second parameter `title`\n\t  shouldReplace\n\t    ? hist.replaceState(null, title, path)\n\t    : hist.pushState(null, title, path);\n\t  // so we need to set it manually\n\t  doc.title = title;\n\t  routeFound = false;\n\t  emit();\n\t  return routeFound\n\t}\n\t\n\t/**\n\t * Go to path or set action\n\t * a single string:                go there\n\t * two strings:                    go there with setting a title\n\t * two strings and boolean:        replace history with setting a title\n\t * a single function:              set an action on the default route\n\t * a string/RegExp and a function: set an action on the route\n\t * @param {(string|function)} first - path / action / filter\n\t * @param {(string|RegExp|function)} second - title / action\n\t * @param {boolean} third - replace flag\n\t */\n\tprot.m = function(first, second, third) {\n\t  if (isString(first) && (!second || isString(second))) { go(first, second, third || false); }\n\t  else if (second) { this.r(first, second); }\n\t  else { this.r('@', first); }\n\t};\n\t\n\t/**\n\t * Stop routing\n\t */\n\tprot.s = function() {\n\t  this.off('*');\n\t  this.$ = [];\n\t};\n\t\n\t/**\n\t * Emit\n\t * @param {string} path - path\n\t */\n\tprot.e = function(path) {\n\t  this.$.concat('@').some(function(filter) {\n\t    var args = (filter === '@' ? parser : secondParser)(normalize(path), normalize(filter));\n\t    if (typeof args != 'undefined') {\n\t      this[TRIGGER].apply(null, [filter].concat(args));\n\t      return routeFound = true // exit from loop\n\t    }\n\t  }, this);\n\t};\n\t\n\t/**\n\t * Register route\n\t * @param {string} filter - filter for matching to url\n\t * @param {function} action - action to register\n\t */\n\tprot.r = function(filter, action) {\n\t  if (filter !== '@') {\n\t    filter = '/' + normalize(filter);\n\t    this.$.push(filter);\n\t  }\n\t\n\t  this.on(filter, action);\n\t};\n\t\n\tvar mainRouter = new Router();\n\tvar route = mainRouter.m.bind(mainRouter);\n\t\n\t// adding base and getPathFromBase to route so we can access them in route.tag's script\n\troute._ = { base: null, getPathFromBase: getPathFromBase };\n\t\n\t/**\n\t * Create a sub router\n\t * @returns {function} the method of a new Router object\n\t */\n\troute.create = function() {\n\t  var newSubRouter = new Router();\n\t  // assign sub-router's main method\n\t  var router = newSubRouter.m.bind(newSubRouter);\n\t  // stop only this sub-router\n\t  router.stop = newSubRouter.s.bind(newSubRouter);\n\t  return router\n\t};\n\t\n\t/**\n\t * Set the base of url\n\t * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n\t */\n\troute.base = function(arg) {\n\t  route._.base = arg || '#';\n\t  current = getPathFromBase(); // recalculate current path\n\t};\n\t\n\t/** Exec routing right now **/\n\troute.exec = function() {\n\t  emit(true);\n\t};\n\t\n\t/**\n\t * Replace the default router to yours\n\t * @param {function} fn - your parser function\n\t * @param {function} fn2 - your secondParser function\n\t */\n\troute.parser = function(fn, fn2) {\n\t  if (!fn && !fn2) {\n\t    // reset parser for testing...\n\t    parser = DEFAULT_PARSER;\n\t    secondParser = DEFAULT_SECOND_PARSER;\n\t  }\n\t  if (fn) { parser = fn; }\n\t  if (fn2) { secondParser = fn2; }\n\t};\n\t\n\t/**\n\t * Helper function to get url query as an object\n\t * @returns {object} parsed query\n\t */\n\troute.query = function() {\n\t  var q = {};\n\t  var href = loc.href || current;\n\t  href.replace(/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v; });\n\t  return q\n\t};\n\t\n\t/** Stop routing **/\n\troute.stop = function () {\n\t  if (started) {\n\t    if (win) {\n\t      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit);\n\t      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n\t      doc[REMOVE_EVENT_LISTENER](clickEvent, click);\n\t    }\n\t\n\t    central[TRIGGER]('stop');\n\t    started = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Start routing\n\t * @param {boolean} autoExec - automatically exec after starting if true\n\t */\n\troute.start = function (autoExec) {\n\t  if (!started) {\n\t    if (win) {\n\t      if (document.readyState === 'interactive' || document.readyState === 'complete') {\n\t        start(autoExec);\n\t      } else {\n\t        document.onreadystatechange = function () {\n\t          if (document.readyState === 'interactive') {\n\t            // the timeout is needed to solve\n\t            // a weird safari bug https://github.com/riot/route/issues/33\n\t            setTimeout(function() { start(autoExec); }, 1);\n\t          }\n\t        };\n\t      }\n\t    }\n\t\n\t    started = true;\n\t  }\n\t};\n\t\n\t/** Prepare the router **/\n\troute.base();\n\troute.parser();\n\t\n\tmodule.exports = route;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t;(function(window, undefined) {var observable = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {}\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given `event` ands\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } event - event id\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(event, fn) {\n\t        if (typeof fn == 'function')\n\t          (callbacks[event] = callbacks[event] || []).push(fn)\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given `event` listeners\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(event, fn) {\n\t        if (event == '*' && !fn) callbacks = {}\n\t        else {\n\t          if (fn) {\n\t            var arr = callbacks[event]\n\t            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t              if (cb == fn) arr.splice(i--, 1)\n\t            }\n\t          } else delete callbacks[event]\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given `event` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(event, fn) {\n\t        function on() {\n\t          el.off(event, on)\n\t          fn.apply(el, arguments)\n\t        }\n\t        return el.on(event, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given `event`\n\t     * @param   { String } event - event id\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(event) {\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns,\n\t          fn,\n\t          i\n\t\n\t        for (i = 0; i < arglen; i++) {\n\t          args[i] = arguments[i + 1] // skip first argument\n\t        }\n\t\n\t        fns = slice.call(callbacks[event] || [], 0)\n\t\n\t        for (i = 0; fn = fns[i]; ++i) {\n\t          fn.apply(el, args)\n\t        }\n\t\n\t        if (callbacks['*'] && event != '*')\n\t          el.trigger.apply(el, ['*', event].concat(args))\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  })\n\t\n\t  return el\n\t\n\t}\n\t  /* istanbul ignore next */\n\t  // support CommonJS, AMD & browser\n\t  if (true)\n\t    module.exports = observable\n\t  else if (typeof define === 'function' && define.amd)\n\t    define(function() { return observable })\n\t  else\n\t    window.observable = observable\n\t\n\t})(typeof window != 'undefined' ? window : undefined);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__(1), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports !== \"undefined\") {\n\t    factory(module, require('riot'), require('extend'));\n\t  } else {\n\t    var mod = {\n\t      exports: {}\n\t    };\n\t    factory(mod, global.riot, global.extend);\n\t    global.router = mod.exports;\n\t  }\n\t})(this, function (module, riot, extend) {\n\t  'use strict';\n\t\n\t  var _slicedToArray = function () {\n\t    function sliceIterator(arr, i) {\n\t      var _arr = [];\n\t      var _n = true;\n\t      var _d = false;\n\t      var _e = undefined;\n\t\n\t      try {\n\t        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t          _arr.push(_s.value);\n\t\n\t          if (i && _arr.length === i) break;\n\t        }\n\t      } catch (err) {\n\t        _d = true;\n\t        _e = err;\n\t      } finally {\n\t        try {\n\t          if (!_n && _i[\"return\"]) _i[\"return\"]();\n\t        } finally {\n\t          if (_d) throw _e;\n\t        }\n\t      }\n\t\n\t      return _arr;\n\t    }\n\t\n\t    return function (arr, i) {\n\t      if (Array.isArray(arr)) {\n\t        return arr;\n\t      } else if (Symbol.iterator in Object(arr)) {\n\t        return sliceIterator(arr, i);\n\t      } else {\n\t        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t      }\n\t    };\n\t  }();\n\t\n\t  function _possibleConstructorReturn(self, call) {\n\t    if (!self) {\n\t      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t    }\n\t\n\t    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t  }\n\t\n\t  var _get = function get(object, property, receiver) {\n\t    if (object === null) object = Function.prototype;\n\t    var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t    if (desc === undefined) {\n\t      var parent = Object.getPrototypeOf(object);\n\t\n\t      if (parent === null) {\n\t        return undefined;\n\t      } else {\n\t        return get(parent, property, receiver);\n\t      }\n\t    } else if (\"value\" in desc) {\n\t      return desc.value;\n\t    } else {\n\t      var getter = desc.get;\n\t\n\t      if (getter === undefined) {\n\t        return undefined;\n\t      }\n\t\n\t      return getter.call(receiver);\n\t    }\n\t  };\n\t\n\t  function _inherits(subClass, superClass) {\n\t    if (typeof superClass !== \"function\" && superClass !== null) {\n\t      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t    }\n\t\n\t    subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t      constructor: {\n\t        value: subClass,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t  }\n\t\n\t  function _classCallCheck(instance, Constructor) {\n\t    if (!(instance instanceof Constructor)) {\n\t      throw new TypeError(\"Cannot call a class as a function\");\n\t    }\n\t  }\n\t\n\t  var _createClass = function () {\n\t    function defineProperties(target, props) {\n\t      for (var i = 0; i < props.length; i++) {\n\t        var descriptor = props[i];\n\t        descriptor.enumerable = descriptor.enumerable || false;\n\t        descriptor.configurable = true;\n\t        if (\"value\" in descriptor) descriptor.writable = true;\n\t        Object.defineProperty(target, descriptor.key, descriptor);\n\t      }\n\t    }\n\t\n\t    return function (Constructor, protoProps, staticProps) {\n\t      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t      if (staticProps) defineProperties(Constructor, staticProps);\n\t      return Constructor;\n\t    };\n\t  }();\n\t\n\t  var error = console && console.error || function () {};\n\t\n\t  var Router = function () {\n\t    function Router() {\n\t      _classCallCheck(this, Router);\n\t\n\t      riot.observable(this);\n\t      this.interceptors = [this.processRoute.bind(this)];\n\t      this.handler = new InitialRoute();\n\t      this.current = new Context(\"\").response;\n\t      this.process = this.process.bind(this);\n\t    }\n\t\n\t    _createClass(Router, [{\n\t      key: 'route',\n\t      value: function route(handler) {\n\t        this.handler = handler;\n\t      }\n\t    }, {\n\t      key: 'routes',\n\t      value: function routes(_routes) {\n\t        this.route(new InitialRoute().routes(_routes));\n\t      }\n\t    }, {\n\t      key: 'use',\n\t      value: function use(interceptor) {\n\t        this.interceptors.push(interceptor);\n\t      }\n\t    }, {\n\t      key: 'process',\n\t      value: function process() {\n\t        var params = Array.prototype.slice.call(arguments);\n\t        var query = {};\n\t        var uri = params.filter(function (p) {\n\t          if (typeof p !== 'string') {\n\t            query = p;\n\t            return false;\n\t          }\n\t          return true;\n\t        }).join(\"/\");\n\t        if (uri[0] !== '/') uri = \"/\" + uri; // handle '#any' as '#/any'\n\t        var context = new Context(new Request(uri, query));\n\t        if (!this.rootContext) this.rootContext = context;\n\t        this.processRequest(context);\n\t        return context;\n\t      }\n\t    }, {\n\t      key: 'processRequest',\n\t      value: function processRequest(context) {\n\t        this.processInterceptors(context);\n\t        return this.processResponse(context);\n\t      }\n\t    }, {\n\t      key: 'processResponse',\n\t      value: function processResponse(context) {\n\t        if (this.isRedirect(context)) {\n\t          return this.processRedirect(context);\n\t        }\n\t        var request = context.request,\n\t            response = context.response;\n\t\n\t        if (!response.redirectTo) {\n\t          this.current = response;\n\t          this.rootContext = null;\n\t          this.trigger('route:updated', response);\n\t          return context;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'isRedirect',\n\t      value: function isRedirect(context) {\n\t        return !!context.response.redirectTo;\n\t      }\n\t    }, {\n\t      key: 'processRedirect',\n\t      value: function processRedirect(context) {\n\t        var uri = context.response.redirectTo;\n\t        this.rootContext.addRedirect(uri);\n\t        this.navigateTo(uri);\n\t      }\n\t    }, {\n\t      key: 'navigateTo',\n\t      value: function navigateTo() {\n\t        var args = Array.prototype.slice.call(arguments);\n\t        if (typeof args[1] === 'boolean') {\n\t          args.splice(1, 0, '');\n\t        }\n\t        this.config.route.apply(null, args);\n\t      }\n\t    }, {\n\t      key: 'processInterceptors',\n\t      value: function processInterceptors(context, preInterceptors, postInterceptors) {\n\t        var interceptors = (preInterceptors || []).concat(this.interceptors).concat(postInterceptors || []);\n\t        var next = function next() {\n\t          if (!context.stop) {\n\t            var processor = interceptors.shift();\n\t            var request = context.request,\n\t                response = context.response;\n\t\n\t            if (processor) return processor(request, response, next, context);\n\t          }\n\t          return context;\n\t        };\n\t        return next();\n\t      }\n\t    }, {\n\t      key: 'processRoute',\n\t      value: function processRoute(request, response, next, context) {\n\t        this.handler.process(request, response, context);\n\t        return next();\n\t      }\n\t    }, {\n\t      key: 'start',\n\t      value: function start() {\n\t        this.config.route.start();\n\t        this.exec();\n\t      }\n\t    }, {\n\t      key: 'exec',\n\t      value: function exec() {\n\t        this.config.route.exec(this.process);\n\t      }\n\t    }, {\n\t      key: 'configure',\n\t      value: function configure(options) {\n\t        this.config = extend(true, {}, this.config, options);\n\t        if (this.config.route.parser && this.config.parser) this.config.route.parser(this.config.parser);\n\t        if (this.config.route.base && this.config.base) this.config.route.base(this.config.base);\n\t        this.config.route(this.process);\n\t      }\n\t    }]);\n\t\n\t    return Router;\n\t  }();\n\t\n\t  var Context = function () {\n\t    function Context(request) {\n\t      _classCallCheck(this, Context);\n\t\n\t      this.request = typeof request === 'string' ? new Request(request) : request;\n\t      this.response = new Response(this.request);\n\t      this.redirectStack = [];\n\t    }\n\t\n\t    _createClass(Context, [{\n\t      key: 'addRedirect',\n\t      value: function addRedirect(uri) {\n\t        if (this.redirectStack.indexOf(uri) > -1) throw new Error(\"Cyclic redirection to \" + uri + \". Stack = \" + this.redirectStack);\n\t        this.redirectStack.push(uri);\n\t      }\n\t    }]);\n\t\n\t    return Context;\n\t  }();\n\t\n\t  var Handler = function () {\n\t    function Handler() {\n\t      _classCallCheck(this, Handler);\n\t    }\n\t\n\t    _createClass(Handler, [{\n\t      key: 'matches',\n\t      value: function matches(request) {\n\t        return false;\n\t      }\n\t    }, {\n\t      key: 'process',\n\t      value: function process(request, response) {\n\t        var matcher = this.matches(request);\n\t        if (!matcher) return this.routeMiss(request, response);\n\t        return this.routeMatch(request, response, matcher);\n\t      }\n\t    }, {\n\t      key: 'routeMatch',\n\t      value: function routeMatch(request, response, matcher) {\n\t        response.add(matcher);\n\t        return true;\n\t      }\n\t    }, {\n\t      key: 'routeMiss',\n\t      value: function routeMiss(request, response) {\n\t        return false;\n\t      }\n\t    }, {\n\t      key: 'processRoutes',\n\t      value: function processRoutes(request, response, routes) {\n\t        if (routes && routes.length) {\n\t          var t = routes.length;\n\t          for (var i = 0; i < t; i++) {\n\t            var route = routes[i];\n\t            if (route.process(request, response)) return true;\n\t          }\n\t          return false;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'createRequest',\n\t      value: function createRequest(request, matcher) {\n\t        return new ChildRequest(request, matcher);\n\t      }\n\t    }]);\n\t\n\t    return Handler;\n\t  }();\n\t\n\t  var Route = function (_Handler) {\n\t    _inherits(Route, _Handler);\n\t\n\t    function Route(options) {\n\t      _classCallCheck(this, Route);\n\t\n\t      var _this = _possibleConstructorReturn(this, (Route.__proto__ || Object.getPrototypeOf(Route)).call(this, options));\n\t\n\t      options = options || {};\n\t      _this.tag = options.tag;\n\t      _this.api = options.api;\n\t      _this.path = options.path;\n\t      _this.name = options.name;\n\t      _this.updatable = options.updatable;\n\t      _this.pathParameterNames = [];\n\t      _this.reRenderOnPropChange = options.reRenderOnPropChange;\n\t      var path = _this.getPath().replace(/^\\//, \"\");\n\t      _this.pattern = \"^/?\" + path.replace(/:([^/]+)/g, function (ignored, group) {\n\t        this.pathParameterNames.push(group);\n\t        return \"([^/]+)\";\n\t      }.bind(_this)) + \"(:?/|$)\";\n\t      _this.regex = new RegExp(_this.pattern);\n\t      return _this;\n\t    }\n\t\n\t    _createClass(Route, [{\n\t      key: 'routes',\n\t      value: function routes(_routes2) {\n\t        var redirectRoutes = _routes2.filter(function (r) {\n\t          return r instanceof RedirectRoute;\n\t        });\n\t        var defaultRoutes = _routes2.filter(function (r) {\n\t          return r instanceof DefaultRoute;\n\t        });\n\t        var notFoundRoutes = _routes2.filter(function (r) {\n\t          return r instanceof NotFoundRoute;\n\t        });\n\t        var otherRoutes = _routes2.filter(function (r) {\n\t          return redirectRoutes.indexOf(r) === -1 && defaultRoutes.indexOf(r) === -1 && notFoundRoutes.indexOf(r) === -1;\n\t        });\n\t        if (notFoundRoutes.length > 1) error(\"Can't use more than one NotFoundRoute per route. --> \" + this.getPath());\n\t        if (defaultRoutes.length > 1) error(\"Can't use more than one DefaultRoute per route. --> \" + this.getPath());\n\t        this._routes = [].concat(redirectRoutes).concat(otherRoutes).concat(defaultRoutes).concat(notFoundRoutes);\n\t        return this;\n\t      }\n\t    }, {\n\t      key: 'matches',\n\t      value: function matches(request) {\n\t        var matcher = this.regex.exec(request.uri);\n\t        if (matcher) {\n\t          var params = {};\n\t          for (var i in this.pathParameterNames) {\n\t            if (this.pathParameterNames.hasOwnProperty(i)) {\n\t              var name = this.pathParameterNames[i];\n\t              params[name] = decodeURIComponent(matcher[parseInt(i, 10) + 1]);\n\t            }\n\t          }\n\t          return {\n\t            route: this,\n\t            tag: this.tag,\n\t            api: this.api,\n\t            found: matcher[0],\n\t            params: params\n\t          };\n\t        }\n\t        return false;\n\t      }\n\t    }, {\n\t      key: 'routeMatch',\n\t      value: function routeMatch(request, response, matcher) {\n\t        var matches = _get(Route.prototype.__proto__ || Object.getPrototypeOf(Route.prototype), 'routeMatch', this).call(this, request, response, matcher);\n\t        this.processRoutes(request, response, matcher);\n\t        return matches;\n\t      }\n\t    }, {\n\t      key: 'processRoutes',\n\t      value: function processRoutes(request, response, matcher) {\n\t        return _get(Route.prototype.__proto__ || Object.getPrototypeOf(Route.prototype), 'processRoutes', this).call(this, this.createRequest(request, matcher), response, this._routes);\n\t      }\n\t    }, {\n\t      key: 'getPath',\n\t      value: function getPath() {\n\t        return this.name || this.path || (typeof this.tag === 'string' ? this.tag : '');\n\t      }\n\t    }]);\n\t\n\t    return Route;\n\t  }(Handler);\n\t\n\t  var InitialRoute = function (_Route) {\n\t    _inherits(InitialRoute, _Route);\n\t\n\t    function InitialRoute() {\n\t      _classCallCheck(this, InitialRoute);\n\t\n\t      return _possibleConstructorReturn(this, (InitialRoute.__proto__ || Object.getPrototypeOf(InitialRoute)).apply(this, arguments));\n\t    }\n\t\n\t    return InitialRoute;\n\t  }(Route);\n\t\n\t  var ChildRequest = function ChildRequest(request, matcher) {\n\t    _classCallCheck(this, ChildRequest);\n\t\n\t    this.request = request;\n\t    this.matcher = matcher;\n\t    this.uri = this.request.uri.substring(matcher.found.length);\n\t    this.parentUri = this.request.uri.substring(0, matcher.found.length);\n\t    this.query = this.request.query;\n\t  };\n\t\n\t  var NotFoundRoute = function (_Handler2) {\n\t    _inherits(NotFoundRoute, _Handler2);\n\t\n\t    function NotFoundRoute(options) {\n\t      _classCallCheck(this, NotFoundRoute);\n\t\n\t      var _this3 = _possibleConstructorReturn(this, (NotFoundRoute.__proto__ || Object.getPrototypeOf(NotFoundRoute)).call(this, options));\n\t\n\t      options = options || {};\n\t      _this3.tag = options.tag;\n\t      _this3.api = options.api;\n\t      return _this3;\n\t    }\n\t\n\t    _createClass(NotFoundRoute, [{\n\t      key: 'matches',\n\t      value: function matches(request) {\n\t        return {\n\t          route: this,\n\t          tag: this.tag,\n\t          api: this.api,\n\t          found: request.uri\n\t        };\n\t      }\n\t    }]);\n\t\n\t    return NotFoundRoute;\n\t  }(Handler);\n\t\n\t  var RedirectRoute = function (_Handler3) {\n\t    _inherits(RedirectRoute, _Handler3);\n\t\n\t    function RedirectRoute(options) {\n\t      _classCallCheck(this, RedirectRoute);\n\t\n\t      var _this4 = _possibleConstructorReturn(this, (RedirectRoute.__proto__ || Object.getPrototypeOf(RedirectRoute)).call(this, options));\n\t\n\t      options = options || {};\n\t      _this4.from = options.from;\n\t      _this4.to = options.to;\n\t      _this4.pattern = \"(^/?)\" + _this4.from + \"(/|$)\";\n\t      _this4.regex = new RegExp(_this4.pattern);\n\t      return _this4;\n\t    }\n\t\n\t    _createClass(RedirectRoute, [{\n\t      key: 'process',\n\t      value: function process(request, response) {\n\t        var uri = request.uri.replace(this.regex, \"$1\" + this.to + \"$2\");\n\t        if (uri !== request.uri) {\n\t          var parent = request.parentUri || \"\";\n\t          response.redirectTo = parent + uri;\n\t          return true;\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return RedirectRoute;\n\t  }(Handler);\n\t\n\t  var DefaultRoute = function (_Handler4) {\n\t    _inherits(DefaultRoute, _Handler4);\n\t\n\t    function DefaultRoute(options) {\n\t      _classCallCheck(this, DefaultRoute);\n\t\n\t      var _this5 = _possibleConstructorReturn(this, (DefaultRoute.__proto__ || Object.getPrototypeOf(DefaultRoute)).call(this, options));\n\t\n\t      options = options || {};\n\t      _this5.tag = options.tag;\n\t      _this5.api = options.api;\n\t      return _this5;\n\t    }\n\t\n\t    _createClass(DefaultRoute, [{\n\t      key: 'matches',\n\t      value: function matches(request) {\n\t        var uri = request.uri.trim();\n\t        if (uri === \"/\" || uri === \"\") return {\n\t          route: this,\n\t          tag: this.tag,\n\t          api: this.api,\n\t          found: uri\n\t        };\n\t      }\n\t    }]);\n\t\n\t    return DefaultRoute;\n\t  }(Handler);\n\t\n\t  var Request = function Request(uri, query) {\n\t    _classCallCheck(this, Request);\n\t\n\t    this.uri = uri;\n\t    this.query = query;\n\t  };\n\t\n\t  var Response = function () {\n\t    function Response(request) {\n\t      _classCallCheck(this, Response);\n\t\n\t      this.uri = request.uri;\n\t      this.matches = [];\n\t      this.params = {};\n\t      this.query = request.query;\n\t    }\n\t\n\t    _createClass(Response, [{\n\t      key: 'add',\n\t      value: function add(matcher) {\n\t        this.matches.push(matcher);\n\t        var params = matcher.params;\n\t        if (params) {\n\t          for (var key in params) {\n\t            if (params.hasOwnProperty(key)) {\n\t              this.params[key] = params[key];\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }, {\n\t      key: 'get',\n\t      value: function get(index) {\n\t        return this.matches[index];\n\t      }\n\t    }, {\n\t      key: 'size',\n\t      value: function size() {\n\t        return this.matches.length;\n\t      }\n\t    }, {\n\t      key: 'isEmpty',\n\t      value: function isEmpty() {\n\t        return this.matches.length;\n\t      }\n\t    }]);\n\t\n\t    return Response;\n\t  }();\n\t\n\t  function registerTag(router) {\n\t    riot.tag('route', '<router-content></router-content>', '', '', function (opts) {\n\t      this.calculateLevel = function (target) {\n\t        var level = 0;\n\t        if (target.parent) level += this.calculateLevel(target.parent);\n\t        if (target.opts.__router_level) level += target.opts.__router_level;\n\t        if (target.__router_tag) level += 1;\n\t        return level;\n\t      }.bind(this);\n\t\n\t      this.normalizeTag = function (tag, api, options) {\n\t        var result = tag(api, options);\n\t        if (typeof result === 'string') {\n\t          tag = result;\n\t        } else {\n\t          tag = result.tag || tag;\n\t          api = result.api || api;\n\t        }\n\t        return [tag, api, options];\n\t      };\n\t\n\t      this.unmountTag = function () {\n\t        if (this.instance) this.instance.unmount(true);\n\t      };\n\t\n\t      this.mountTag = function (tag, api, options) {\n\t        if (typeof tag === 'function') {\n\t          var _normalizeTag = this.normalizeTag(tag, api, options);\n\t\n\t          var _normalizeTag2 = _slicedToArray(_normalizeTag, 3);\n\t\n\t          tag = _normalizeTag2[0];\n\t          api = _normalizeTag2[1];\n\t          options = _normalizeTag2[2];\n\t        }\n\t        if (this.canUpdate(tag, api, options)) {\n\t          console.debug('Tag \\'' + tag + '\\' will be updated, instead of re-rendered.');\n\t          // TODO This is incorrect, needs to be fixed pay attention to transfer from one virtual sport to another\n\t          this.instance.update(extend({}, api, { opts: api }));\n\t        } else {\n\t          this.unmountTag();\n\t          if (tag) {\n\t            this.root.replaceChild(document.createElement(tag), this.root.children[0]);\n\t            try {\n\t              this.instance = riot.mount(this.root.children[0], tag, api)[0];\n\t            } catch (e) {\n\t              error(\"Error when mounting tag '\" + tag + \"'.\", e);\n\t              return;\n\t            }\n\t            this.instanceTag = tag;\n\t            this.instanceApi = api;\n\t          }\n\t        }\n\t      };\n\t\n\t      this.canUpdate = function (tag, api, options) {\n\t        var _this6 = this;\n\t\n\t        if (options.reRenderOnPropChange && this.instanceApi && options.reRenderOnPropChange.some(function (opt) {\n\t          return _this6.instanceApi[opt] !== api[opt];\n\t        })) {\n\t          return false; // When a prop is not equal to previous, and the flag reRenderOnPropChange is set, then we need to full re-render\n\t        }\n\t        if (options.updatable === false) return false;\n\t        if (!router.config.updatable && !opts.updatable && !options.updatable || !this.instance || !this.instance.isMounted || this.instanceTag !== tag) return false;\n\t        return true;\n\t      };\n\t\n\t      this.updateRoute = function () {\n\t        var mount = {\n\t          tag: null\n\t        };\n\t        if (router && router.current) {\n\t          var response = router.current;\n\t          if (this.level <= response.size()) {\n\t            var matcher = response.get(this.level);\n\t            if (matcher) {\n\t              var params = matcher.params || {};\n\t              var query = response.query || {};\n\t              var api = extend(true, {}, opts, query, matcher.api, params, {\n\t                __router_level: this.level,\n\t                query: query\n\t              });\n\t              mount = {\n\t                tag: matcher.tag,\n\t                api: api,\n\t                updatable: matcher.route.updatable,\n\t                reRenderOnPropChange: matcher.route.reRenderOnPropChange\n\t              };\n\t            }\n\t          }\n\t        }\n\t        if (mount.tag) this.mountTag(mount.tag, mount.api, mount);else this.unmountTag();\n\t      }.bind(this);\n\t\n\t      this.__router_tag = 'route';\n\t      this.level = this.calculateLevel(this);\n\t      router.on('route:updated', this.updateRoute);\n\t      this.on('unmount', function () {\n\t        router.off('route:updated', this.updateRoute);\n\t        this.unmountTag();\n\t      }.bind(this));\n\t      this.on('mount', this.updateRoute);\n\t    });\n\t  }\n\t\n\t  function detectRoute() {\n\t    var route = riot.route || window && window.route || global && global.route;\n\t    return route;\n\t  }\n\t\n\t  function create(config) {\n\t    var router = new Router();\n\t    router.configure(extend(true, {\n\t      updatable: true,\n\t      route: detectRoute(),\n\t      base: '#',\n\t      parser: function customRiotParser(path) {\n\t        var raw = path.split('?'),\n\t            uri = raw[0].split('/'),\n\t            query = raw[1],\n\t            params = {};\n\t        if (query) {\n\t          query.split('&').forEach(function (v) {\n\t            var c = v.split('=');\n\t            params[c[0]] = c[1];\n\t          });\n\t        }\n\t        uri.push(params);\n\t        return uri;\n\t      }\n\t    }, config));\n\t    registerTag(router);\n\t    if (!Router.instance) Router.instance = router;\n\t    return router;\n\t  }\n\t  Router.create = create;\n\t  Router.Route = Route;\n\t  Router.DefaultRoute = DefaultRoute;\n\t  Router.RedirectRoute = RedirectRoute;\n\t  Router.NotFoundRoute = NotFoundRoute;\n\t  Router._ = {\n\t    Response: Response,\n\t    Request: Request\n\t  };\n\t  module.exports = Router;\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar defineProperty = Object.defineProperty;\n\tvar gOPD = Object.getOwnPropertyDescriptor;\n\t\n\tvar isArray = function isArray(arr) {\n\t\tif (typeof Array.isArray === 'function') {\n\t\t\treturn Array.isArray(arr);\n\t\t}\n\t\n\t\treturn toStr.call(arr) === '[object Array]';\n\t};\n\t\n\tvar isPlainObject = function isPlainObject(obj) {\n\t\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\t\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t\t// Not own constructor property must be Object\n\t\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tvar key;\n\t\tfor (key in obj) { /**/ }\n\t\n\t\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n\t};\n\t\n\t// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\n\tvar setProperty = function setProperty(target, options) {\n\t\tif (defineProperty && options.name === '__proto__') {\n\t\t\tdefineProperty(target, options.name, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: options.newValue,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t} else {\n\t\t\ttarget[options.name] = options.newValue;\n\t\t}\n\t};\n\t\n\t// Return undefined instead of __proto__ if '__proto__' is not an own property\n\tvar getProperty = function getProperty(obj, name) {\n\t\tif (name === '__proto__') {\n\t\t\tif (!hasOwn.call(obj, name)) {\n\t\t\t\treturn void 0;\n\t\t\t} else if (gOPD) {\n\t\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\t\treturn gOPD(obj, name).value;\n\t\t\t}\n\t\t}\n\t\n\t\treturn obj[name];\n\t};\n\t\n\tmodule.exports = function extend() {\n\t\tvar options, name, src, copy, copyIsArray, clone;\n\t\tvar target = arguments[0];\n\t\tvar i = 1;\n\t\tvar length = arguments.length;\n\t\tvar deep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === 'boolean') {\n\t\t\tdeep = target;\n\t\t\ttarget = arguments[1] || {};\n\t\t\t// skip the boolean and the target\n\t\t\ti = 2;\n\t\t}\n\t\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\tfor (; i < length; ++i) {\n\t\t\toptions = arguments[i];\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif (options != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\t\tcopy = getProperty(options, name);\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target !== copy) {\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\t\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// router.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b2141e00868f4f4f7858","var riot = require('riot');\nvar route = require('riot-route');\nvar Router = require('./src/router.js');\nvar router = Router.create({route: route});\nif (window) {\n    window.router = router;\n}\nmodule.exports = Router;\n\n\n\n\n// WEBPACK FOOTER //\n// ./router.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"riot\"\n// module id = 1\n// module chunks = 0 1","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar observable = _interopDefault(require('riot-observable'));\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\nvar RE_ORIGIN = /^.+?\\/\\/+[^/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = typeof window != 'undefined' && window,\n  doc = typeof document != 'undefined' && document,\n  hist = win && history,\n  loc = win && (hist.location || win.location), // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  central = observable();\n\nvar\n  started = false,\n  routeFound = false,\n  debouncedEmit,\n  current,\n  parser,\n  secondParser,\n  emitStack = [],\n  emitStackLevel = 0;\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var f = filter\n    .replace(/\\?/g, '\\\\?')\n    .replace(/\\*/g, '([^/?#]+?)')\n    .replace(/\\.\\./, '.*');\n  var re = new RegExp((\"^\" + f + \"$\"));\n  var args = path.match(re);\n\n  if (args) { return args.slice(1) }\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t;\n  return function () {\n    clearTimeout(t);\n    t = setTimeout(fn, delay);\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1);\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit);\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n  doc[ADD_EVENT_LISTENER](clickEvent, click);\n\n  if (autoExec) { emit(true); }\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = [];\n  observable(this); // make it observable\n  central.on('stop', this.s.bind(this));\n  central.on('emit', this.e.bind(this));\n}\n\nfunction normalize(path) {\n  return path.replace(/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href).replace(RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  var base = route._.base;\n  return base[0] === '#'\n    ? (href || loc.href || '').split(base)[1] || ''\n    : (loc ? getPathFromRoot(href) : href || '').replace(base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel === 0;\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) { return }\n\n  emitStackLevel++;\n  emitStack.push(function() {\n    var path = getPathFromBase();\n    if (force || path !== current) {\n      central[TRIGGER]('emit', path);\n      current = path;\n    }\n  });\n\n  if (isRoot) {\n    var first;\n    while (first = emitStack.shift()) { first(); } // stack increses within this call\n    emitStackLevel = 0;\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which !== 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) { return }\n\n  var el = e.target;\n  while (el && el.nodeName !== 'A') { el = el.parentNode; }\n\n  if (\n    !el || el.nodeName !== 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target !== '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) === -1 // cross origin\n  ) { return }\n\n  var base = route._.base;\n\n  if (el.href !== loc.href\n    && (\n      el.href.split('#')[0] === loc.href.split('#')[0] // internal jump\n      || base[0] !== '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || base[0] === '#' && el.href.split(base)[0] !== loc.href.split(base)[0] // outside of #base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    )) { return }\n\n  if (!Object.keys(el).find(function (key) { return key.includes('react') })) {\n    e.preventDefault();\n  }\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  // Server-side usage: directly execute handlers for the path\n  if (!hist) { return central[TRIGGER]('emit', getPathFromBase(path)) }\n\n  path = route._.base + normalize(path);\n  title = title || doc.title;\n  // browsers ignores the second parameter `title`\n  shouldReplace\n    ? hist.replaceState(null, title, path)\n    : hist.pushState(null, title, path);\n  // so we need to set it manually\n  doc.title = title;\n  routeFound = false;\n  emit();\n  return routeFound\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function(first, second, third) {\n  if (isString(first) && (!second || isString(second))) { go(first, second, third || false); }\n  else if (second) { this.r(first, second); }\n  else { this.r('@', first); }\n};\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*');\n  this.$ = [];\n};\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter === '@' ? parser : secondParser)(normalize(path), normalize(filter));\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args));\n      return routeFound = true // exit from loop\n    }\n  }, this);\n};\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter !== '@') {\n    filter = '/' + normalize(filter);\n    this.$.push(filter);\n  }\n\n  this.on(filter, action);\n};\n\nvar mainRouter = new Router();\nvar route = mainRouter.m.bind(mainRouter);\n\n// adding base and getPathFromBase to route so we can access them in route.tag's script\nroute._ = { base: null, getPathFromBase: getPathFromBase };\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router();\n  // assign sub-router's main method\n  var router = newSubRouter.m.bind(newSubRouter);\n  // stop only this sub-router\n  router.stop = newSubRouter.s.bind(newSubRouter);\n  return router\n};\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  route._.base = arg || '#';\n  current = getPathFromBase(); // recalculate current path\n};\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true);\n};\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER;\n    secondParser = DEFAULT_SECOND_PARSER;\n  }\n  if (fn) { parser = fn; }\n  if (fn2) { secondParser = fn2; }\n};\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {};\n  var href = loc.href || current;\n  href.replace(/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v; });\n  return q\n};\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit);\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click);\n    }\n\n    central[TRIGGER]('stop');\n    started = false;\n  }\n};\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState === 'interactive' || document.readyState === 'complete') {\n        start(autoExec);\n      } else {\n        document.onreadystatechange = function () {\n          if (document.readyState === 'interactive') {\n            // the timeout is needed to solve\n            // a weird safari bug https://github.com/riot/route/issues/33\n            setTimeout(function() { start(autoExec); }, 1);\n          }\n        };\n      }\n    }\n\n    started = true;\n  }\n};\n\n/** Prepare the router **/\nroute.base();\nroute.parser();\n\nmodule.exports = route;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot-route/index.js\n// module id = 2\n// module chunks = 0",";(function(window, undefined) {var observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          (callbacks[event] = callbacks[event] || []).push(fn)\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) callbacks = {}\n        else {\n          if (fn) {\n            var arr = callbacks[event]\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) arr.splice(i--, 1)\n            }\n          } else delete callbacks[event]\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on)\n          fn.apply(el, arguments)\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments[i + 1] // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0)\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args)\n        }\n\n        if (callbacks['*'] && event != '*')\n          el.trigger.apply(el, ['*', event].concat(args))\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  })\n\n  return el\n\n}\n  /* istanbul ignore next */\n  // support CommonJS, AMD & browser\n  if (typeof exports === 'object')\n    module.exports = observable\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return observable })\n  else\n    window.observable = observable\n\n})(typeof window != 'undefined' ? window : undefined);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot-observable/dist/observable.js\n// module id = 3\n// module chunks = 0","var riot = require('riot');\nvar extend = require('extend');\nvar error = console && console.error || function () {};\n\nclass Router {\n  constructor() {\n    riot.observable(this);\n    this.interceptors = [this.processRoute.bind(this)];\n    this.handler = new InitialRoute();\n    this.current = new Context(\"\").response;\n    this.process = this.process.bind(this);\n  }\n\n  route(handler) {\n    this.handler = handler;\n  }\n\n  routes(routes) {\n    this.route(new InitialRoute().routes(routes));\n  }\n\n  use(interceptor) {\n    this.interceptors.push(interceptor);\n  }\n\n  process() {\n    var params = Array.prototype.slice.call(arguments);\n    var query = {};\n    var uri = params.filter(function (p) {\n      if (typeof (p) !== 'string') {\n        query = p;\n        return false;\n      }\n      return true;\n    }).join(\"/\");\n    if (uri[0] !== '/') uri = \"/\" + uri; // handle '#any' as '#/any'\n    var context = new Context(new Request(uri, query));\n    if (!this.rootContext) this.rootContext = context;\n    this.processRequest(context);\n    return context;\n  }\n\n  processRequest(context) {\n    this.processInterceptors(context);\n    return this.processResponse(context);\n  }\n\n  processResponse(context) {\n    if (this.isRedirect(context)) {\n      return this.processRedirect(context);\n    }\n    var {\n      request,\n      response\n    } = context;\n    if (!response.redirectTo) {\n      this.current = response;\n      this.rootContext = null;\n      this.trigger('route:updated', response);\n      return context;\n    }\n  }\n\n  isRedirect(context) {\n    return !!context.response.redirectTo;\n  }\n\n  processRedirect(context) {\n    var uri = context.response.redirectTo;\n    this.rootContext.addRedirect(uri);\n    this.navigateTo(uri);\n  }\n\n  navigateTo() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof(args[1]) === 'boolean') {\n      args.splice(1, 0, '');\n    }\n    this.config.route.apply(null, args);\n  }\n\n  processInterceptors(context, preInterceptors, postInterceptors) {\n    var interceptors = (preInterceptors || []).concat(this.interceptors).concat(postInterceptors || []);\n    var next = function next() {\n      if (!context.stop) {\n        var processor = interceptors.shift();\n        var {\n          request,\n          response\n        } = context;\n        if (processor)\n          return processor(request, response, next, context);\n      }\n      return context;\n    };\n    return next();\n  }\n\n  processRoute(request, response, next, context) {\n    this.handler.process(request, response, context);\n    return next();\n  }\n\n  start() {\n    this.config.route.start();\n    this.exec();\n  }\n\n  exec() {\n    this.config.route.exec(this.process);\n  }\n\n  configure(options) {\n    this.config = extend(true, {}, this.config, options);\n    if (this.config.route.parser && this.config.parser)\n      this.config.route.parser(this.config.parser);\n    if (this.config.route.base && this.config.base)\n      this.config.route.base(this.config.base);\n    this.config.route(this.process);\n  }\n\n}\n\nclass Context {\n  constructor(request) {\n    this.request = typeof (request) === 'string' ? new Request(request) : request;\n    this.response = new Response(this.request);\n    this.redirectStack = [];\n  }\n\n  addRedirect(uri) {\n    if (this.redirectStack.indexOf(uri) > -1)\n      throw new Error(\"Cyclic redirection to \" + uri + \". Stack = \" + this.redirectStack);\n    this.redirectStack.push(uri);\n  }\n\n}\n\nclass Handler {\n  constructor() {}\n\n  matches(request) {\n    return false;\n  }\n\n  process(request, response) {\n    var matcher = this.matches(request);\n    if (!matcher) return this.routeMiss(request, response);\n    return this.routeMatch(request, response, matcher);\n  }\n\n  routeMatch(request, response, matcher) {\n    response.add(matcher);\n    return true;\n  }\n\n  routeMiss(request, response) {\n    return false;\n  }\n\n  processRoutes(request, response, routes) {\n    if (routes && routes.length) {\n      var t = routes.length;\n      for (var i = 0; i < t; i++) {\n        var route = routes[i];\n        if (route.process(request, response))\n          return true;\n      }\n      return false;\n    }\n  }\n\n  createRequest(request, matcher) {\n    return new ChildRequest(request, matcher);\n  }\n}\n\nclass Route extends Handler {\n  constructor(options) {\n    super(options);\n    options = options || {};\n    this.tag = options.tag;\n    this.api = options.api;\n    this.path = options.path;\n    this.name = options.name;\n    this.updatable = options.updatable;\n    this.pathParameterNames = [];\n    this.reRenderOnPropChange = options.reRenderOnPropChange;\n    var path = this.getPath().replace(/^\\//, \"\");\n    this.pattern = \"^/?\" + path.replace(/:([^/]+)/g, function (ignored, group) {\n      this.pathParameterNames.push(group);\n      return \"([^/]+)\";\n    }.bind(this)) + \"(:?/|$)\";\n    this.regex = new RegExp(this.pattern);\n  }\n\n  routes(routes) {\n    var redirectRoutes = routes.filter(function (r) {\n      return r instanceof RedirectRoute;\n    });\n    var defaultRoutes = routes.filter(function (r) {\n      return r instanceof DefaultRoute;\n    });\n    var notFoundRoutes = routes.filter(function (r) {\n      return r instanceof NotFoundRoute;\n    });\n    var otherRoutes = routes.filter(function (r) {\n      return redirectRoutes.indexOf(r) === -1 &&\n        defaultRoutes.indexOf(r) === -1 &&\n        notFoundRoutes.indexOf(r) === -1;\n    });\n    if (notFoundRoutes.length > 1) error(\"Can't use more than one NotFoundRoute per route. --> \" + this.getPath());\n    if (defaultRoutes.length > 1) error(\"Can't use more than one DefaultRoute per route. --> \" + this.getPath());\n    this._routes = [].concat(redirectRoutes).concat(otherRoutes).concat(defaultRoutes).concat(notFoundRoutes);\n    return this;\n  }\n\n  matches(request) {\n    var matcher = this.regex.exec(request.uri);\n    if (matcher) {\n      var params = {};\n      for (var i in this.pathParameterNames) {\n        if (this.pathParameterNames.hasOwnProperty(i)) {\n          var name = this.pathParameterNames[i];\n          params[name] = decodeURIComponent(matcher[parseInt(i, 10) + 1]);\n        }\n      }\n      return {\n        route: this,\n        tag: this.tag,\n        api: this.api,\n        found: matcher[0],\n        params: params\n      };\n    }\n    return false;\n  }\n\n  routeMatch(request, response, matcher) {\n    var matches = super.routeMatch(request, response, matcher);\n    this.processRoutes(request, response, matcher);\n    return matches;\n  }\n\n  processRoutes(request, response, matcher) {\n    return super.processRoutes(this.createRequest(request, matcher), response, this._routes);\n  }\n\n  getPath() {\n    return this.name || this.path || (typeof this.tag === 'string' ? this.tag : '');\n  }\n}\n\nclass InitialRoute extends Route {\n\n}\n\nclass ChildRequest {\n  constructor(request, matcher) {\n    this.request = request;\n    this.matcher = matcher;\n    this.uri = this.request.uri.substring(matcher.found.length);\n    this.parentUri = this.request.uri.substring(0, matcher.found.length);\n    this.query = this.request.query;\n  }\n}\n\nclass NotFoundRoute extends Handler {\n  constructor(options) {\n    super(options);\n    options = options || {};\n    this.tag = options.tag;\n    this.api = options.api;\n  }\n  matches(request) {\n    return {\n      route: this,\n      tag: this.tag,\n      api: this.api,\n      found: request.uri\n    };\n  }\n}\n\nclass RedirectRoute extends Handler {\n  constructor(options) {\n    super(options);\n    options = options || {};\n    this.from = options.from;\n    this.to = options.to;\n    this.pattern = \"(^/?)\" + this.from + \"(/|$)\";\n    this.regex = new RegExp(this.pattern);\n  }\n\n  process(request, response) {\n    var uri = request.uri.replace(this.regex, \"$1\" + this.to + \"$2\");\n    if (uri !== request.uri) {\n      var parent = request.parentUri || \"\";\n      response.redirectTo = parent + uri;\n      return true;\n    }\n  }\n\n}\n\nclass DefaultRoute extends Handler {\n  constructor(options) {\n    super(options);\n    options = options || {};\n    this.tag = options.tag;\n    this.api = options.api;\n  }\n  matches(request) {\n    var uri = request.uri.trim();\n    if (uri === \"/\" || uri === \"\")\n      return {\n        route: this,\n        tag: this.tag,\n        api: this.api,\n        found: uri\n      };\n  }\n}\n\nclass Request {\n  constructor(uri, query) {\n    this.uri = uri;\n    this.query = query;\n  }\n}\n\nclass Response {\n  constructor(request) {\n    this.uri = request.uri;\n    this.matches = [];\n    this.params = {};\n    this.query = request.query;\n  }\n  add(matcher) {\n    this.matches.push(matcher);\n    var params = matcher.params;\n    if (params) {\n      for (var key in params) {\n        if (params.hasOwnProperty(key)) {\n          this.params[key] = params[key];\n        }\n      }\n    }\n  }\n\n  get(index) {\n    return this.matches[index];\n  }\n\n  size() {\n    return this.matches.length;\n  }\n\n  isEmpty() {\n    return this.matches.length;\n  }\n\n}\n\nfunction registerTag(router) {\n  riot.tag('route', '<router-content></router-content>', '', '', function (opts) {\n    this.calculateLevel = function (target) {\n      var level = 0;\n      if (target.parent) level += this.calculateLevel(target.parent);\n      if (target.opts.__router_level) level += target.opts.__router_level;\n      if (target.__router_tag) level += 1;\n      return level;\n    }.bind(this);\n\n    this.normalizeTag = function (tag, api, options) {\n      var result = tag(api, options);\n      if (typeof result === 'string') {\n        tag = result;\n      } else {\n        tag = result.tag || tag;\n        api = result.api || api;\n      }\n      return [tag, api, options];\n    }\n\n    this.unmountTag = function () {\n      if (this.instance)\n        this.instance.unmount(true);\n    }\n\n    this.mountTag = function (tag, api, options) {\n      if (typeof tag === 'function') {\n        [tag, api, options] = this.normalizeTag(tag, api, options);\n      }\n      if (this.canUpdate(tag, api, options)) {\n        console.debug(`Tag '${tag}' will be updated, instead of re-rendered.`);\n        // TODO This is incorrect, needs to be fixed pay attention to transfer from one virtual sport to another\n        this.instance.update(extend({}, api, { opts: api }));\n      } else {\n        this.unmountTag();\n        if (tag) {\n          this.root.replaceChild(document.createElement(tag), this.root.children[0]);\n          try {\n            this.instance = riot.mount(this.root.children[0], tag, api)[0];\n          } catch (e) {\n            error(\"Error when mounting tag '\" + tag + \"'.\", e);\n            return;\n          }\n          this.instanceTag = tag;\n          this.instanceApi = api;\n        }\n      }\n    }\n\n    this.canUpdate = function (tag, api, options) {\n      if (options.reRenderOnPropChange && this.instanceApi && options.reRenderOnPropChange.some(opt => this.instanceApi[opt] !== api[opt])) {\n        return false; // When a prop is not equal to previous, and the flag reRenderOnPropChange is set, then we need to full re-render\n      }\n      if (options.updatable === false) return false;\n      if ((!router.config.updatable && !opts.updatable && !options.updatable) ||\n        !this.instance ||\n        !this.instance.isMounted ||\n        this.instanceTag !== tag)\n        return false;\n      return true;\n    }\n\n    this.updateRoute = function () {\n      var mount = {\n        tag: null\n      };\n      if (router && router.current) {\n        var response = router.current;\n        if (this.level <= response.size()) {\n          var matcher = response.get(this.level);\n          if (matcher) {\n            var params = matcher.params || {};\n            var query = response.query || {};\n            var api = extend(true, {}, opts, query, matcher.api, params, {\n              __router_level: this.level,\n              query: query\n            });\n            mount = {\n              tag: matcher.tag,\n              api: api,\n              updatable: matcher.route.updatable,\n              reRenderOnPropChange: matcher.route.reRenderOnPropChange,\n            };\n          }\n        }\n      }\n      if (mount.tag)\n        this.mountTag(mount.tag, mount.api, mount);\n      else\n        this.unmountTag();\n    }.bind(this);\n\n    this.__router_tag = 'route';\n    this.level = this.calculateLevel(this);\n    router.on('route:updated', this.updateRoute);\n    this.on('unmount', function () {\n      router.off('route:updated', this.updateRoute);\n      this.unmountTag();\n    }.bind(this));\n    this.on('mount', this.updateRoute);\n  });\n}\n\nfunction detectRoute() {\n  var route = riot.route ||\n    (window && window.route) ||\n    (global && global.route);\n  return route;\n}\n\nfunction create(config) {\n  var router = new Router();\n  router.configure(extend(true, {\n    updatable: true,\n    route: detectRoute(),\n    base: '#',\n    parser: function customRiotParser(path) {\n      var raw = path.split('?'),\n        uri = raw[0].split('/'),\n        query = raw[1],\n        params = {}\n      if (query) {\n        query.split('&').forEach(function (v) {\n          var c = v.split('=')\n          params[c[0]] = c[1]\n        })\n      }\n      uri.push(params)\n      return uri\n    }\n  }, config));\n  registerTag(router);\n  if (!Router.instance) Router.instance = router;\n  return router;\n}\nRouter.create = create;\nRouter.Route = Route;\nRouter.DefaultRoute = DefaultRoute;\nRouter.RedirectRoute = RedirectRoute;\nRouter.NotFoundRoute = NotFoundRoute;\nRouter._ = {\n  Response: Response,\n  Request: Request\n};\nmodule.exports = Router;\n\n\n\n// WEBPACK FOOTER //\n// ./src/router.js","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extend/index.js\n// module id = 5\n// module chunks = 0 1"],"sourceRoot":""}